# Main()之前做的事情
*	优先应该知道Main()函数调用前做了什么，以及可执行文件的格式Mach-O文件
	*	系统加载Mach-o文件
	* 	动态链接库工作
		*	Load dylibs
		* 	rebase image
		*  	bind image (绑定符号) 
	*	Objc init (这时候执行load方法)
	* 	找到主程序入口 执行Main()函数     
* 	Mach-O文件格式介绍
	*	一般的可执行文件由文件头header、加载命令Load Command、具体数据Segment组成
		*	Header   它的作用是使系统能够快速定位其运行环境以及文件类型
			```
			struct mach_header_64 {
				uint32_t	magic;		/* mach magic 标识符 */
				cpu_type_t	cputype;	/* CPU 类型标识符，同通用二进制格式中的定义 */
				cpu_subtype_t	cpusubtype;	/* CPU 子类型标识符，同通用二级制格式中的定义 */
				uint32_t	filetype;	/* 文件类型 */
				uint32_t	ncmds;		/* 加载器中加载命令的条数 */
				uint32_t	sizeofcmds;	/* 加载器中加载命令的总大小 */
				uint32_t	flags;		/* dyld 的标志 */
				uint32_t	reserved;	/* 64 位的保留字段 */
			};
			```
		* 	Load Command		描述了文件中数据的具体组织架构，不同的数据类型使用不同的加载命令表示
			*	不同的加载命令有不同的专有的结构体。这些加载命令告诉系统应该如何处理后面的二进制数据，对系统内核加载器和动态链接器起指导作用。LC_SEGMENT意味着这部分文件需要映射到进程的地址空间去。  
		*  	具体数据	Data中每一个段Segment的数据都保存在此，段的概念和ELF文件中的段的概念类似，都拥有一个或者多个Section，用来存放数据和代码
			*	段名主要有__PAGEZERO （空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对NULL指针的引用） __TEXT（包含了执行代码以及其他只读数据，该段数据可以读、执行，不能被修改） __DATA（程序数据，可读写执行） __LINKEDIT (链接器使用的符号以及其他表)  
			* 	关于Segment以及Section结构体的定义可以参考文章或者MachOView工具查看
			```
			段名为大写，节名为小写。各节的作用主要有：
			
				__text:　主程序代码
				__stub_helper:　用于动态链接的存根
				__symbolstub1:　用于动态链接的存根
				__objc_methname:　Objective-C 的方法名
				__objc_classname:　Objective-C 的类名
				__cstring:　硬编码的字符串
				
				__lazy_symbol:　懒加载，延迟加载节，通过 dyld_stub_binder 辅助链接
				_got:　存储引用符号的实际地址，类似于动态符号表
				__nl_symbol_ptr:　非延迟加载节
				__mod_init_func:　初始化的全局函数地址，在 main 之前被调用
				__mod_term_func:　结束函数地址
				__cfstring:　Core Foundation 用到的字符串（OC字符串）
				
				__objc_clsslist:　Objective-C 的类列表
				__objc_nlclslist:　Objective-C 的 +load 函数列表，比 __mod_init_func 更早执行
				__objc_const:　Objective-C 的常量
				__data:　初始化的可变的变量
				__bss:　未初始化的静态变量
			```
	*	基本内容如上所述，有关于Mach-O文件重点可能应该放在__DATA.__la_symbol_ptr和__DATA.__nl_symbol_ptr这两个指针表上，分别为Lazybinding和Nonlazybinding指针表
		*	dyld(the dynamic link editor)动态链接，它的作用简单点说就是负责将各种各样程序需要的镜像加载到程序运行的内存空间中，这个过程发生的非常早，在objc运行时初始化前。 
			*	Lazy Binding过程  __stubs和__stub_helper区是帮助动态链接器找到指定数据段__nl_symbol_ptr 在运行时，动态链接器会根据dynamic loader info信息，把数据段__la_symbol_ptr指向真正的符号地址。通过__nl_symbol_ptr中转是因为数据权限的问题？？？动态绑定符号的执行者 dyld_stub_binder（这里逻辑很混乱，大概是编译后如果是动态库中的func，则在此mach-o文件中有关该符号的定义为未定义的，在合适的时机（具体时机是：nl_symbol_ptr在动态链接库绑定的时候进行加载，__la_symbol_ptr是在该符号被第一次焦勇的时候通过dyld_stub_binder方法重新绑定未定义的符号指向函数真正的实现地址）
			*  FishHook原理：dyld通过更新Mach-O二进制文件__DATA段中的一些指针来绑定lazy和non-lazy的符号；而FishHook先确定一个符号在__DATA段中的位置，然后保存原有符号对应的对应的函数指针，并使用新的函数指针覆盖原有符号的函数指针，实现重绑定（666）
	*	虚拟内存分配问题 
*	Main()之后的问题
	*	准备图片解码
	* 	布局阶段
	*  	绘制阶段
	*   (基本思想就是异步，将消耗时间的业务异步执行或者延迟执行)
# 针对整个加载过程中可以做的事情
*	Hook系统方法
* 	启动加速
*  重新实现编译期定义的东西？？？


#	C为什么不能跨平台
-	 一般程序的编译过程
	-	预处理阶段
	-	编译阶段
	-	汇编阶段
		-	本地机器码
		-	指令集
	-	链接阶段
-	因为最终产生的二进制代码都是针对不同类型的CPU而产生的，所以C编译后的文件不能实现跨平台。
-		

# 参考链接
* [1](https://feicong.github.io/2017/01/14/dylib/)   
* [2](https://mp.weixin.qq.com/s/fdDPyjRkVf9AdWiikBagHg)
* [3](https://mp.weixin.qq.com/s/I60p2M-IHDmeUanDUkFdVw)
* [4](https://www.desgard.com/fishhook-1/)
* [5](https://amywushu.github.io/2017/02/27/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Hook-%E5%8E%9F%E7%90%86%E4%B9%8B-fishhook-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html)
* [6](https://techblog.toutiao.com/2017/01/17/iosspeed/)
# Main()之前做的事情
*	`Main()`函数之前的加载过程
	
	*	系统加载`Mach-O`文件
	* 	动态链接库工作
		*	`Load dylibs`
		* 	`rebase image`
		*  	`bind image` (绑定符号) 
	*	`Objc init` (这时候执行`load`方法)
	* 	找到主程序入口 执行`Main()`函数     
	
* 	`Mach-O`文件格式介绍
	*	一般的可执行文件由文件头`header`、加载命令`Load Command`、具体数据`Segment`组成
		*	`Header`它的作用是使系统能够快速定位其运行环境以及文件类型
			
			```c
			struct mach_header_64 {
				uint32_t	magic;		/* mach magic 标识符 */
				cpu_type_t	cputype;	/* CPU 类型标识符，同通用二进制格式中的定义 */
				cpu_subtype_t	cpusubtype;	/* CPU 子类型标识符，同通用二级制格式中的定义 */
				uint32_t	filetype;	/* 文件类型 */
				uint32_t	ncmds;		/* 加载器中加载命令的条数 */
				uint32_t	sizeofcmds;	/* 加载器中加载命令的总大小 */
				uint32_t	flags;		/* dyld 的标志 */
				uint32_t	reserved;	/* 64 位的保留字段 */
			};
			```
		* 	`Load Command`描述了文件中数据的具体组织架构，不同的数据类型使用不同的加载命令表示
			
			*	不同的加载命令有不同的专有的结构体。这些加载命令告诉系统应该如何处理后面的二进制数据，对系统内核加载器和动态链接器起指导作用。`LC_SEGMENT`意味着这部分文件需要映射到进程的地址空间去。  
			
		*  	具体数据`Data`中每一个段`Segment`的数据都保存在此，段的概念和ELF文件中的段的概念类似，都拥有一个或者多个`Section`，用来存放数据和代码
			*	段名主要有
			    *	`__PAGEZERO` （空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对NULL指针的引用） 
			    *	`__TEXT`（包含了执行代码以及其他只读数据，该段数据可以读、执行，不能被修改） 
			    *	`__DATA`（程序数据，可读写执行）
			    *	` __LINKEDIT` (链接器使用的符号以及其他表)  
			* 	关于`Segment`以及`Section`结构体的定义可以参考文章或者`MachOView`工具查看
			```c
			//段名为大写，节名为小写。各节的作用主要有：
			
				__text:　主程序代码
				__stub_helper:　用于动态链接的存根
				__symbolstub1:　用于动态链接的存根
				__objc_methname:　Objective-C 的方法名
				__objc_classname:　Objective-C 的类名
				__cstring:　硬编码的字符串
				
				__lazy_symbol:　懒加载，延迟加载节，通过 dyld_stub_binder 辅助链接
				_got:　存储引用符号的实际地址，类似于动态符号表
				__nl_symbol_ptr:　非延迟加载节
				__mod_init_func:　初始化的全局函数地址，在 main 之前被调用
				__mod_term_func:　结束函数地址
				__cfstring:　Core Foundation 用到的字符串（OC字符串）
				
				__objc_clsslist:　Objective-C 的类列表
				__objc_nlclslist:　Objective-C 的 +load 函数列表，比 __mod_init_func 更早执行
				__objc_const:　Objective-C 的常量
				__data:　初始化的可变的变量
				__bss:　未初始化的静态变量
			```
		
	*	基本内容如上所述，有关于`Mach-O`文件重点可能应该放在`__DATA.__la_symbol_ptr`和`__DATA.__nl_symbol_ptr`这两个指针表上，分别为`Lazybinding`和`Nonlazybinding`指针表
		*	`dyld(the dynamic link editor)`动态链接，它的作用简单点说就是负责将各种各样程序需要的镜像加载到程序运行的内存空间中，这个过程发生的非常早，在`objc`运行时初始化前。 
			*	`Lazy Binding`过程 ` __stubs`和`__stub_helper`区是帮助动态链接器找到指定数据段`__nl_symbol_ptr` 在运行时，动态链接器会根据`dynamic loader info`信息，把数据段`__la_symbol_ptr`指向真正的符号地址。通过`__nl_symbol_ptr`中转是因为数据权限的问题？？？动态绑定符号的执行者 `dyld_stub_binder`（这里逻辑很混乱，大概是编译后如果是动态库中的`func`，则在此`mach-o`文件中有关该符号的定义为未定义的，在合适的时机（具体时机是：`nl_symbol_ptr`在动态链接库绑定的时候进行加载，`__la_symbol_ptr`是在该符号被第一次焦勇的时候通过`dyld_stub_binder`方法重新绑定未定义的符号指向函数真正的实现地址）
			*  `FishHook`原理：`dyld`通过更新`Mach-O`二进制文件`__DATA`段中的一些指针来绑定`lazy`和`non-lazy`的符号；而`FishHook`先确定一个符号在`__DATA`段中的位置，然后保存原有符号对应的对应的函数指针，并使用新的函数指针覆盖原有符号的函数指针，实现重绑定（666）
		
	*	虚拟内存分配问题 
	
*	`XNU`加载`Mach-O`和`dyld`流程

    *	`load_init_program`
        *	负责加载系统初始化的过程，非`debug`下，只会加载`launchd`(是一个负责进程管理的后台守护进程`daemon`)
    *	`__mac_execve`
        *	：启用新进程和`task`，调用`exec_activate_image`
    *	`exec_activate_image`
        *	负责按照`binary`的格式分发映射内存，格式三种：单指令`binary`,`Fat Binary`,`shell脚本`，如果是`Fat binary`,会先进行指令集级别`Mach-O`的分解，然后在循环`execsw`来分发进行映射
    *	`exec_mach_imgact`
        *	为`vfork`生成新的线程
        *	把`Mach-O`映射到内存
        *	签名、`uid`等权限处理，`dyld`相关的处理工作
        *	释放资源
    *	`load_machfile`
        *	负责除了`Mach-O`解析之外所有和加载相关的工作
            *	为当前`task`分配可执行内存，`task`是任务实例，负责进程内的虚拟内存空间，线程管理等工作
            *	`Mach-O`和`dyld`地址随机化`ASLR`的随机
            *	为`exec_mach_imgact`回传结果
        *	在这个函数中，调用了`vm_map_create`函数，这个函数中创建了虚拟内存，里面传入了一个`App`最大的虚拟内存空间`vm_compute_max_offset`，根据里面定义的函数值可以得到最大值为`2^36`,就是`64G`。
    *	`parse_machfile`
        *	`Mach-O`的解析，相关`segment`虚拟内存分配
        *	`dyld`的加载
        *	`dyld`的解析以及虚拟内存分配
    *	

*	虚拟内存分布

    *	当`RAM`不够用的时候会使用一部分`ROM`来充当内存使用，在需要时候进行数据交换，但是交换速度比较慢，这也是内存过载的时候，`APP`卡顿的原因之一。

*	`Main()`之后的问题
	
	*	准备图片解码
	* 	布局阶段
	*  	绘制阶段
	*   (基本思想就是异步，将消耗时间的业务异步执行或者延迟执行)
# 针对整个加载过程中可以做的事情
*	`Hook`系统方法
* 	启动加速
*  重新实现编译期定义的东西？？？


#	C为什么不能跨平台
-	 一般程序的编译过程
	-	预处理阶段
	-	编译阶段
	-	汇编阶段
		-	本地机器码
		-	指令集
	-	链接阶段
-    因为最终产生的二进制代码都是针对不同类型的CPU而产生的，所以C编译后的文件不能实现跨平台。

     

# 参考链接

* [dylib动态库加载过程分析](https://feicong.github.io/2017/01/14/dylib/)   
* [XNU、dyld 源码分析，Mach-O和动态库的加载过程 (下)](https://mp.weixin.qq.com/s/fdDPyjRkVf9AdWiikBagHg)
* [XNU、dyld源码分析Mach-O和动态库的加载过程(上)](https://mp.weixin.qq.com/s/I60p2M-IHDmeUanDUkFdVw)
* [巧用符号表 - 探求 fishhook 原理（一）](https://www.desgard.com/fishhook-1/)
* [Hook 原理之 fishhook 源码解析](https://amywushu.github.io/2017/02/27/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Hook-%E5%8E%9F%E7%90%86%E4%B9%8B-fishhook-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html)
* [今日头条iOS客户端启动速度优化
](https://techblog.toutiao.com/2017/01/17/iosspeed/)
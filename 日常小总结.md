# Runloop
* 原理
	* KCFRunloopModeRef
	* KCFRunloopTimerRef
	* KCFRunloopSourceRef
	* KCFRunloopObserverRef
* ASDK的使用
	* 通过创建低优先级的observer监听在runloop即将进入睡眠阶段时执行任务 
* AFNetWorking的使用
	* 在2.x的版本上只是为了常驻线程，避免线程开销.首先需要在子线程去start connection，请求发送后，所在的子线程需要保活以保证正常接收到 NSURLConnectionDelegate 回调方法。如果每来一个请求就开一条线程，并且保活线程，这样开销太大了。所以只需要保活一条固定的线程，在这个线程里发起请求、接收回调。
	* 在3.0的版本中貌似移除了常驻线程，原因是使用了NSURLSession，这个类可以指派自己的回调线程 

# MMAP
* mmap是通过一次内存地址映射减少了一次拷贝过程
* 常规的文件操作为了提高读写效率和保护磁盘，使用了缓存页，步骤如下
	* 磁盘<---->页缓存<---->内存对应的用户空间
* mmap步骤 
	* 磁盘<-----> 虚拟内存区域
* 优点： 提高效率，进程间通信，但是需要注意对比操作内存大小判断这样的操作有无必要
* 使用注意细节： mmap映射区域大小必须是物理页大小（page_size）的整数倍。原因是内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位的。
* 现阶段发现的例子：
	* MMKV:基于MMAP的iOS高性能通用key-value组件
	* FastImageCache：iOS图片加载速度极限优化
		* 传统图片加载步骤
			* 从磁盘拷贝数据到内核缓冲区
			* 从内核缓冲区复制数据到用户空间
			* 生成UIImageView，把图像数据赋值给UIImageView
			* 如果图像数据为未解码的PNG/JPG，解码为位图数据
			* CATransaction捕获到UIImageView layer树的变化
			* 主线程Runloop提交CATransaction，开始进行图像渲染
			* 6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐。
			* 6.2 GPU处理位图数据，进行渲染
		* 优化集中点
			* 使用MMAP内存映射，省去上述第二步数据从内核空间拷贝到用户空间的操作
			* 缓存解码后的位图数据到磁盘，下次从磁盘读取时省去第4步解码的操作（bitmap会很大）
			* 生成字节对齐的数据，防止上述6.1步CoreAnimation在渲染时再拷贝一份数据 

# Block
* block分为_NSConcreteStackBlock，_NSConcreteMallocBlock，_NSConcreteGlobalBlock。
* weakself的作用只是弱引用一个指针，strongself会在block执行的作用域使weakself不能释放，延迟weakself的释放时机
* 如下情况，系统都会默认调用copy方法把block赋值到堆
	* 手动调用copy
	* block是函数的返回值
	* block被强引用，block被赋值给__strong或者id类型
	* 调用系统api入参中含有usingBlock的方法
* 变量的捕获
	* 自动变量
		* 是将变量的值付给block，在内部结构体赋值，所以无法改变 int val = __cself->val;
	* 全局变量和静态全局变量
		* 因为是全局的，作用域很广
	* 静态变量
  		*  因为传递的内存地址，所以可以改变值
* __block的原理(存储域类说明符))
	* 普通非对象的变量
		*  带有__block的变量被转化成了一个结构体__Block_byref_i_0，
		*  ARC环境下，一旦Block赋值给__strong修饰的指针就会触发copy，__block就会copy到堆上，Block也是__NSMallocBlock。ARC环境下也是存在__NSStackBlock的时候，这种情况下，__block就在栈上。
MRC环境下，只有copy，__block才会被复制到堆上，否则，__block一直都在栈上，block也只是__NSStackBlock，这个时候__forwarding指针就只指向自己了。
		* 对象的变量
			* 在ARC环境下，对于声明__block的外部对象，在block内部会进行retain，以至于在bloc环境内能安全的引用外部对象，所以才有循环引用的问题
			* 有__block修饰的变量会被block Retain ， 无__block修饰的变量只会简单的copy，无循环引用问题？？？ ARC下__block的作用是什么呢？？？
			* arc下__block修饰对象变量无效得原因是默认__strong修饰符 mrc则没有 by_ref by_copy的区别
			* 带有__block修饰的各种变量在创建时就被修改为结构体
			* Block_object_assign 分配内存关键代码 __block修饰的常量，对象都会转成结构体保存，未加block修饰的对象变量也是执行此方法，未加block修饰的常量仅仅是值传递，所以不能修改。
			* 源码查看方式 clang -rewrite-objc main.m
	* 不用类型block的copy效果
		* 栈block： 执行copy的时候，不仅复制了内容，而且添加了一些额外的东西
			* 往flags中并入了BLOCK_NEEDS_FREE（这个标志表明block需要释放，在release时和再次拷贝的时候会用到）
			* 如果有辅助函数BLOCK_HAS_COPY_DISPOSE，那么就调用这个函数，用来拷贝block捕获的变量的
		* 堆block：如果block的flags有BLOCK_NEEDS_FREE标志，就执行latching_incr_int操作，功能是让block的引用计数+1
		* 全局block：直接返回传入的block   
		* enum {
        /* See function implementation for a more complete description of these fields and combinations 
        // 是一个对象
        BLOCK_FIELD_IS_OBJECT   =  3,  /* id, NSObject, ((NSObject)), block, ... 
        // 是一个block
        BLOCK_FIELD_IS_BLOCK    =  7,  /* a block variable 
        // 被__block修饰的变量
        BLOCK_FIELD_IS_BYREF    =  8,  /* the on stack structure holding the block variable 
        // 被__weak修饰的变量，只能被辅助copy函数使用
        BLOCK_FIELD_IS_WEAK     = 16,   declared weak, only used in byref copy helpers 
        // block辅助函数调用（告诉内部实现不要进行retain或者copy）
        BLOCK_BYREF_CALLER      = 128   called from __block (byref) copy/dispose support routines. 
    }; 
    * __block总结 在mrc下，使用了mrc的对象变量在创建时执行_block_object_assign是传入的flag是131 这个值表示内部不错retain或者copy 
* [参考自霜神文章](https://www.jianshu.com/p/ee9756f3d5f6)
* [Block技巧与底层解析](https://www.jianshu.com/p/51d04b7639f1)

# 锁
* 类型主要有信号量（semaphore_t）、互斥锁（nslock，synchornized）、自旋锁（OSSpinLock）、递归锁（NSRecursiveLock）、条件锁（NSConditionLock、NSCondition）、读写锁（rwlock）、分布式锁
* synchornized 其实是objc_sync_enter和objc_sync_exit的成对使用，
	* 内部将token转换成结构体存储，利用自己定义的hash算法存储，hash算法是指针在内存中的地址转化为无符号整型并右移五位，在和数组长度做按位与运算，保证结果不会超出数组大小 

# Runtime
* 四道小题
	* [self class]与[super class]的输出问题
	*  isKindOfClass与isMemberOfClass的结果问题
	*  void* obj = &cls的内存分配执行输出问题
	*  NSObject的Category实例方法与类方法通过类图查找能否执行的问题
* 归根到底全是结构体~~~   

# iOS中触摸事件传递和响应原理
* 系统响应阶段
	* 手指触摸屏幕，屏幕感受到触目后，将事件交由IOKit
	* IOKit将触摸事件封装成IOHIDEvent，并通过mark port传递给SpringBoard进程 
	* SPringboard由于收到了触摸事件，因此触发了系统进程的主进程的Runloop的source回调，发生触摸事件的时候，可能得接受者为系统进程以及前台App进程，如果是前台进程，则通过IPC传递给前台进程
* App响应
	*  App进程的machport接受来自Springboard的触摸事件，主线程的runloop被唤醒，触发source1回调，
	*  source1回调又触发了一个source0的回调，将接受的IOHIDEvent对象封装成一个UIEvent对象，此时App将正式开始对于一个触摸事件的响应
	*  source0回调将触摸事件添加到UIApplication的事件队列，当触摸事件的队列出队后，UIApplication为触摸事件寻找最佳响应者
	*	寻找最佳响应者的具体流程如下
		*	UIApplication首先将事件传递给窗口对象，如果有多个，则选择最后加上的一个
		* 	若window能响应这个事件，则继续向其子视图传递，向子视图传递时也是先传递给最后加上的子视图
		*  若子视图无法响应该事件，则返回父视图，再传递给倒数第二个加入该父视图的子视图
		*  当视图出现下列情况时，不能响应该事件
			*	触摸点不在视图范围内
			* 	不允许交互
			* 	隐藏视图
			*  透明度<=0.01
		*	寻找最佳响应者的原理是hitTest:withEvent方法，默认实现是
			*	若当前视图无法响应事件，返回nil
			* 	若当前视图能响应事件，但是没有子视图能响应事件，则返回当前视图
			*  若当前视图能响应事件，同时有子视图能响应事件，则返回子视图层次中的事件响应者

			``` objc
			- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    //3种状态无法响应事件
     if (self.userInteractionEnabled == NO || self.hidden == YES ||  self.alpha <= 0.01) return nil; 
    //触摸点若不在当前视图上则无法响应事件
    if ([self pointInside:point withEvent:event] == NO) return nil; 
    //从后往前遍历子视图数组 
    int count = (int)self.subviews.count; 
    for (int i = count - 1; i >= 0; i--) 
    { 
        // 获取子视图
        UIView *childView = self.subviews[i]; 
        // 坐标系的转换,把触摸点在当前视图上坐标转换为在子视图上的坐标
        CGPoint childP = [self convertPoint:point toView:childView]; 
        //询问子视图层级中的最佳响应视图
        UIView *fitView = [childView hitTest:childP withEvent:event]; 
        if (fitView) 
        {
            //如果子视图中有更合适的就返回
            return fitView; 
        }
    } 
    //没有在子视图中找到更合适的响应视图，那么自身就是最合适的
    return self;
}
			```
		* 配合方法 pointInside：withEvent 这个方法是判断触摸点是否在视图范围内
	* 至此找到了最佳响应者，开始进入响应流程-响应链
		*	每一个响应者都有一个nextResponder方法，用过获取当前响应者对象的下一个响应者，因此，当事件的最佳响应者确定了，那么整个响应链也就确定了
		*	UIResponder 、 UIGestureRecognizer 、 UIControl的优先级问题
			*	手势识别器优先于最佳响应者的响应，在手势识别器识别成功手势后，调用最佳响应者的touchesCancelled方法终止最佳响应者对于事件的响应
			*	当响应链上有手势识别器的时候，事件的传递过程中一定会先传递给响应链上的手势识别器，然后才传递给最佳响应者，当响应链上的手势识别了时候后，就会取消最佳响应者对于事件的响应。事件传递给响应链上的手势识别器的时候是乱序的，并不是按照响应链从顶到底传递，但是最后响应的函数还是响应链最顶端的手势识别器函数
			* 	UIControl会阻止父视图上的手势识别器的行为，也就是在UIControl的执行优先级比父视图上面的UIGestureRecognizer要高，但是比UIControl自身的UIGestureRecognizer优先级要低
			
* 	参考链接：[iOS中事件传递和响应过程](https://www.jianshu.com/p/4aeaf3aa0c7e)     

# CALayer相关

*	在iOS中所有的视图都从一个叫做UIView的基类派生而来，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换，或者简单的动画
* 	CALayer的概念和UIView差不多，和UIView最大的不同时CALayer不处理用户的交互
*  每一个UIView都有一个CALayer的实例的图层属性，也就是所谓的BackingLayer。iOS设计UIView和CALayer的目的是职责分离。实际上有两个层级关系，视图层级、图层树、渲染树、呈现树
*  	UIView没有暴露出来的功能
	*	阴影、圆角、带颜色的边框
	* 	3D变换
	*  	非矩形范围
	*  透明遮罩
	*  多级非线性动画
*	CALayer相关
	* 寄宿图 contents 类型为id 需要转换
	* Custom Rrawing
		*	drawRect
		* 	自定义实现CALayerDelegate 当CALayer需要进行一些绘制工作时，会向他的代理请求。UIView默认实现了这个代理
		*  布局等各种api相关
	*	隐式动画
		*	事务CATransaction CoreAnimation在每个runloop周期中自动开始一个新的事务，即时不显式的用[CATransaction begin]开始一次事务，任何在一次runloop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画
		* 	完成块：
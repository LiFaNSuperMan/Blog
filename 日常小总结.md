# Runloop
* 原理
	* KCFRunloopModeRef
	* KCFRunloopTimerRef
	* KCFRunloopSourceRef
	* KCFRunloopObserverRef
* ASDK的使用
	* 通过创建低优先级的observer监听在runloop即将进入睡眠阶段时执行任务 
* AFNetWorking的使用
	* 在2.x的版本上只是为了常驻线程，避免线程开销.首先需要在子线程去start connection，请求发送后，所在的子线程需要保活以保证正常接收到 NSURLConnectionDelegate 回调方法。如果每来一个请求就开一条线程，并且保活线程，这样开销太大了。所以只需要保活一条固定的线程，在这个线程里发起请求、接收回调。
	* 在3.0的版本中貌似移除了常驻线程，原因是使用了NSURLSession，这个类可以指派自己的回调线程 

# MMAP
* mmap是通过一次内存地址映射减少了一次拷贝过程
* 常规的文件操作为了提高读写效率和保护磁盘，使用了缓存页，步骤如下
	* 磁盘<---->页缓存<---->内存对应的用户空间
* mmap步骤 
	* 磁盘<-----> 虚拟内存区域
* 优点： 提高效率，进程间通信，但是需要注意对比操作内存大小判断这样的操作有无必要
* 使用注意细节： mmap映射区域大小必须是物理页大小（page_size）的整数倍。原因是内存的最小粒度是页，而进程虚拟地址空间和内存的映射也是以页为单位的。
* 现阶段发现的例子：
	* MMKV:基于MMAP的iOS高性能通用key-value组件
	* FastImageCache：iOS图片加载速度极限优化
		* 传统图片加载步骤
			* 从磁盘拷贝数据到内核缓冲区
			* 从内核缓冲区复制数据到用户空间
			* 生成UIImageView，把图像数据赋值给UIImageView
			* 如果图像数据为未解码的PNG/JPG，解码为位图数据
			* CATransaction捕获到UIImageView layer树的变化
			* 主线程Runloop提交CATransaction，开始进行图像渲染
			* 6.1 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐。
			* 6.2 GPU处理位图数据，进行渲染
		* 优化集中点
			* 使用MMAP内存映射，省去上述第二步数据从内核空间拷贝到用户空间的操作
			* 缓存解码后的位图数据到磁盘，下次从磁盘读取时省去第4步解码的操作（bitmap会很大）
			* 生成字节对齐的数据，防止上述6.1步CoreAnimation在渲染时再拷贝一份数据 

# Block
* block分为_NSConcreteStackBlock，_NSConcreteMallocBlock，_NSConcreteGlobalBlock。
* 如下情况，系统都会默认调用copy方法把block赋值到堆
	* 手动调用copy
	* block是函数的返回值
	* block被强引用，block被赋值给__strong或者id类型
	* 调用系统api入参中含有usingBlock的方法
* 变量的捕获
	* 自动变量
		* 是将变量的值付给block，在内部结构体赋值，所以无法改变 int val = __cself->val;
	* 全局变量和静态全局变量
		* 因为是全局的，作用域很广
	* 静态变量
  		*  因为传递的内存地址，所以可以改变值
* __block的原理
	* 普通非对象的变量
		*  带有__block的变量被转化成了一个结构体__Block_byref_i_0，
		*  ARC环境下，一旦Block赋值就会触发copy，__block就会copy到堆上，Block也是__NSMallocBlock。ARC环境下也是存在__NSStackBlock的时候，这种情况下，__block就在栈上。
MRC环境下，只有copy，__block才会被复制到堆上，否则，__block一直都在栈上，block也只是__NSStackBlock，这个时候__forwarding指针就只指向自己了。
		* 对象的变量
			* 在ARC环境下，对于声明__block的外部对象，在block内部会进行retain，以至于在bloc环境内能安全的引用外部对象，所以才有循环引用的问题
			* 有__block修饰的变量会被block Retain ， 无__block修饰的变量只会简单的copy，无循环引用问题？？？ ARC下__block的作用是什么呢？？？
			* arc下__block修饰对象变量无效得原因是默认__strong修饰符 mrc则没有 by_ref by_copy的区别
			* 带有__block修饰的各种变量在创建时就被修改为结构体
			* Block_object_assign 分配内存关键代码 __block修饰的常量，对象都会转成结构体保存，未加block修饰的对象变量也是执行此方法，未加block修饰的常量仅仅是值传递，所以不能修改。
			* 源码查看方式 clang -rewrite-objc main.m
	* 不用类型block的copy效果
		* 栈block： 执行copy的时候，不仅复制了内容，而且添加了一些额外的东西
			* 往flags中并入了BLOCK_NEEDS_FREE（这个标志表明block需要释放，在release时和再次拷贝的时候会用到）
			* 如果有辅助函数BLOCK_HAS_COPY_DISPOSE，那么就调用这个函数，用来拷贝block捕获的变量的
		* 堆block：如果block的flags有BLOCK_NEEDS_FREE标志，就执行latching_incr_int操作，功能是让block的引用计数+1
		* 全局block：直接返回传入的block    
* [参考自霜神文章](https://www.jianshu.com/p/ee9756f3d5f6)
* [Block技巧与底层解析](https://www.jianshu.com/p/51d04b7639f1)
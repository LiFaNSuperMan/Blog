##第三章 暴力枚举

* 火柴棍拼数
	- 时间复杂度O(n²)，a+b=c，枚举a和b的值算出c的值然后如果a、b、c的火柴数量正好等m-4则为正确解
* 数的全排列

##万能的搜索
* 不撞南墙不回头-深度优先搜索（Depth First Search , DFS）
	- 向下递归，循环枚举，下一层的递归完成重置上一层的递归条件
	- 代码如下：
	``` 
		dfs(int step){
			1.判断边界和是否已经达到条件 return
			2.尝试每一种可能 
			for(i =1 ;i<=n ;i++){
				继续下一步dfs(step + 1)
			}
			return
		}
	```
	- 针对部分需求需要利用books[]控制循环体
* 广度优先搜索（Breadth First Search , BFS）， 尝试每一个点的最多可能性

## 图的遍历
* 图的邻接矩阵存储法 
* 深度优先遍历是沿着图的某一条分支遍历直到末端，然后回溯，在沿着另一条进行同样的遍历，直到所有的顶点都被访问到为止
* 广度优先遍历，适用于所以边的权值都相同的情况
* 城市地图例子
* 飞机转机例子

## 最短路径（未细看）
* Floyd-Warshall算法-核心代码如下：（注意临界值的判断                                                                                                                                                                                                                                                                                                                                                                                                                                           ）
	``` c
	for(k=1;k<=n;k++){
		for(i=1;i<=n;i++){
			for(j=1;j<=n;j++){
				if(e[i][j] > e[i][k] + e[j][k]){
					e[i][j] = e[i][k] + e[j][k];				}
			}
		}
	}
	```
* Dijkstra算法-单源最短路:主要思想是通过边来松弛i号顶点到其余各个顶点的路程
* Bellman-Ford算法
* Bellman-Ford算法的队列优化

## 神奇的树
* 树 -> 二叉树 -> 满二叉树、完全二叉树
	* 满二叉树：严格的定义为深度为h且有(2^h) -1结点的树
	* 完全二叉树：严格的定义为：若设二叉树的高度为h，除h层外，其他的各层（1~h-1）的结点树都达到最大数，第h层从右向左连续缺少若干点，则这个二叉树是完美二叉树
	* 堆排序：大顶堆、小顶堆。利用堆的特性调整堆顶和创建这种类型的堆。
	* 并查集

## 更多精彩算法

* 图的最小生成树 
* Manacher算法：计算最长回文子串 时间复杂度O(n)                                                                         
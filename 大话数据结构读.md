# 大话数据结构

### 第一章 - 概述
* 根据视角的不同，分为逻辑结构和物理结构
* 逻辑结构是对象之间的相互关系：1、集合结构 2、线性结构 3、树形结构 4、图形结构
* 物理结构（存储结构）:顺序存储结构、链式存储结构

### 第二章 - 算法
* 基本概念 各种性质

## 第三章 - 线性表
* 零个或者多个数据的有限序列
* 线性表的顺序存储结构 线性表的长度小于数组的长度 查询、插入、删除
* 链表的创建、删除、插入
* 静态链表

### 第四章 - 栈与队列
* 栈和队列都是特殊的线性表 只不过是对插入和删除做了限制操作
* 栈：限定在表尾进行插入和删除操作的线性表 后进先出
* 栈的顺序存储结构和链式存储结构
* 后缀表达式（逆波兰RPN）中缀表达式转成后缀表达式充分利用了栈的后进先出特性进行推导和计算
* 队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表 先入先出 插入队尾 删除队头
* 循环队列和链队列 队列的顺序存贮和链式存贮 控制入与出的节点

### 第五章 - 串
* 串是由零个或者多个字符组成的有限序列，又名字符串
* ASCII码与Unicode编码的前256个字符相同
* 顺序存储结构新能优于链式存储结构 动态在堆申请内存
* KMP模式匹配算法 改进在于减少不必要的回溯(实现有点麻烦)

### 第六章 - 树
* 数是n（n≥0）个结点的有限集。n=0是称为空树。在任意一个非空树中：
1 有且仅有一个特定的称为根（root）的结点，
2 当n>1时，其余结点可分为m（m>0）个互不相交的有限集，其中每一个集合本身也是一个树，并且称为根的子树（subtree）
* 三种不同的表示法：双亲表示法、孩子表示法、孩子兄弟表示法
* 二叉树是n个节点的有限集合，该集合或者为空集或者由一个根节点和两颗互不相交的分别称为根结点的左子树和右子树的二叉树组成
* 斜树、满二叉树、完全二叉树
* 二叉树的顺序存储结构和链式存储结构（顺序存储适用性差、二叉链表）
* 遍历二叉树（前序、中序、后序、层序），依据给出的结果推论出树的结构
* 线索二叉树，树
* 赫夫曼编码（Daivd Huffman）带权路径长度WPL最小的二叉树称做赫夫曼数，也做最优二叉树
* 一般的。设需要编码的字符集为「d1,d2,d3...dn」,各个字符在电文中出现的次数或者频率为「w1,w2,w3...wn」，以d作为叶子结点，以w作为相应叶子结点的权值来构造一个赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根节点到叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，这就是赫夫曼编码。

### 第七章 - 图（待完成）
* 图（graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E),其中，G表示一个图，V是图G中顶点的结合，E是图G中边的集合
* 无向边(Vi,Vj)任意有一个无向边就是无向图 有向边<Vi,Vj>任意两个顶点之间的边都是有向边则是有向图
* 无向完全图

### 第八章 - 查找
* 二分查找、插值查找[二分查找的优化 核心思想是mid值得查找 (key - a[low])/(a[high] - a[low])] 斐波那契查找（黄金分割找key值）
* 线性索引查找：分块索引、倒排索引、二叉树排序（解决插入与删除的高成本问题）
* 二叉排序树：左子树不空则左子树上所有结点的值均小于他的根结构的值，右子树不空则右子树上所有的结点均大于根结点的值，左右字数各为二叉排序树
* 二叉排序树的查找、添加都很简单。删除操作需要判断是否具有双子树
* 平衡二叉树是一种二叉排序树，其实每一个节点的左子树和右子树的高度差至多等于1(AVL树)
* 平衡二叉树的校准？？？ 
* 多路查找树
* 散列表查找（哈希表）概述：key值取法：数字分析法（适用于事先已知关键字的分布且均匀）、平方取中法（不知道关键字的分布，但是位数很大的情况）、折叠法（不需要知道关键字的分布，关键字位数较多的情况）、除留余数法（常用，p值得选取比较重要，通常p为小于或者等于表长的最小质数或者不包含小小于20质因子的合数）、随机数法
* 散列表查找性能影响因素：散列函数是否均匀、处理冲突的方法、散列表的装填因子

### 第九章 - 排序
* 七种常用排序算法，其中冒泡排序、简单选择排序、和直接插入排序属于简单算法，希尔排序、堆排序、归并排序、快速排序属于改进算法。
* 冒泡算法(直接找到最小值做交换) 时间复杂度 O(n²) 可利用flag标志位进行优化
* 简单选择排序(找到值的index值，利用最小的index值做交换) 时间复杂度O(n²) 性能相对于冒泡较好，在于值得存取 
* 直接插入排序(类似扑克牌的排序)，将大于temp的数字整体向后移动，然后插入找到的temp值
* 希尔排序：基本有序和局部有序
* 堆排序：堆是具有下列性质的完全二叉树：每个结点的值都大于或者等于其左右孩子结点的值，称为大顶堆，或者每个结点的值都小于或者等于其左右孩子结点的值，称为小顶堆;堆排序就是利用这个原理取顶点值后，然后取出或者限制顶点值然后将剩下的数字重新构建符合这个性质的堆。时间复杂度O(nlogn).注意二叉树的深度问题。从数组长度的一半开始。 i节点的双亲应为i/2
* 归并排序:利用递归将长数组二分最小后排序，然后合并，合并核心：
```c
	if(SR[i] < TR[j]){
		HR[k] = SR[i++]
	}else{
		HR[k] = TR[j++]
	}
	// for循环比较两个函数的值，然后将值存入，有可能存在子数组不匹配的情况，这时候要循环的后面将有可能剩余的数字存入最终结果中
```
时间复杂度：O(nlogn) ，存在非递归实现方法，空间复杂度低，
* 快排:时间复杂度：O(nlogn)，在选取第一个low值的时候可以做一些优化操作，采用九数取中合理一些
* 各个排序的时间复杂度如下图
![时间复杂度](https://upload-images.jianshu.io/upload_images/1238950-cf7e6739dafb5ad1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)